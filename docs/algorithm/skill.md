## 解题技巧

### Fisher-Yates 洗牌算法

- 在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换
- 主要用于随机打乱数组


### Knuth-Morris-Pratt算法（简称KMP）

- [link](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)
- [link2](https://blog.csdn.net/daaikuaichuan/article/details/80719203)

- 主要用于串匹配
- “真前缀”指**除了自身以外**，一个字符串的全部头部组合；”真后缀”指**除了自身以外**，一个字符串的全部尾部组合。
- 假设主串A ”BBC ABCDAB ABCDABCDABDE”，需要找出 A 中是否有字符串 B ”ABCDABD”，循环对比 a 和 b 对应位置的值，算出真前缀和真后缀的最大共有元素长度，例如匹配到最后一位 ”D“ 失败了，计算出 ”ABCDAB” 的最大共有元素长度为2 也就是 首尾都有一个 “AB”，直接从 ”ABCDABD” 的 第二位C继续匹配，也就是跳过了重复的 ”AB“



### 算法验证对数器

- 准备样本随机生成器
- 准备一个绝对正确但是复杂度不好的算法
- 将待验证算法和绝对正确算法压测，比较



#### 主定理与递归时间复杂度的计算

- 主定理：如果有一个问题规模为 n，递推的子问题数量为 a，每个子问题的规模为n/b（假设每个子问题的规模基本一样），递推以外进行的计算工作为 f(n)（比如归并排序，需要合并序列，则 f(n)就是合并序列需要的运算量），那么对于这个问题有如下递推关系式：
- ![](https://cdn.jsdelivr.net/gh/freshchen/resource@master/img/main1.jpe)
- 然后就可以套公式估算递归的时间复杂度
- ![](https://cdn.jsdelivr.net/gh/freshchen/resource@master/img/main2.jpe)



#### 并查集

- 用于解决
  - 两个元素是否在同一个集合（优化，查的过程中把路过的节点直接连头节点）
  - 合并两个元素所在的集合
- 实现
  - 数组
  - 双HashMap



#### 跳跃表

- 特点

  - 最底层包含所有节点的一个有序的链表
  - 每一层都是一个有序的链表
  - 每个节点都有两个指针，一个指向右侧节点（没有则为空），一个指向下层节点（没有则为空）
  - 必备一个头节点指向最高层的第一个节点，通过它可以遍历整张表

  ![](https://cdn.jsdelivr.net/gh/freshchen/resource@master/img/skip-list.jpg)



#### 前缀树/字典树（Trie）

- 用于解决
  - 常用于快速检索
  - 大量字符串的排序和统计
- 基本性质
  - 根节点不包含字符，除根节点外每个节点只包含一个字符
  - 从根节点到某个节点，路径上所有的字符连接起来，就是这个节点所对应的字符串
  - 每个节点的子节点所包含的字符都不同

#### 如何从暴力递归改动态规范

- 首先写好一个暴力递归
  - 分析这个递归是否有重复计算
  - 分析这个递归的当前状态和之前递归计算的顺序是不是无关
  - 如果都满足就可以改成动态规划
- 改写成DP
  - 找出递归中变化的参数
  - 确定递归的开始位置
  - 确定一些边界或者特殊情况
  - 抽象出一次递归的步骤，分析步骤和已经固定的边界的关系
  - 找出规律后coding

#### 布隆过滤（Bloom Filter）

- **解决问题**：判断一个元素是否在一个集合中，优势是只需要占用很小的内存空间以及有着高效的查询效率

- **原理**：保存了很长的二进制向量，同时结合 Hash 函数实现

  - 首先需要k个hash函数，每个函数可以把key散列成为1个整数
  - 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
  - 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
  - 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

- **特点**

  - 只要返回数据不存在，则肯定不存在
  - 返回数据存在，只能是大概率存在
  - 不能清除其中的数据

- **计算误差**

  - 先根据样本大小n，可以接受的误差p，计算需要申请多大内存m

    ![](https://cdn.jsdelivr.net/gh/freshchen/resource@master/img/bloom1.png)

  - 再由m，n得到hash function的个数k

    ![](https://cdn.jsdelivr.net/gh/freshchen/resource@master/img/bloom2.png)

  - 再计算实际的误差p

    ![](https://cdn.jsdelivr.net/gh/freshchen/resource@master/img/bloom3.png)