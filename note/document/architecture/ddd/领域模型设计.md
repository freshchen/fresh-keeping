---
begin: 2021-11-12
status: done
rating: 1
---

# 领域模型设计

## 有哪些领域模型

1.  值对象（Value Object）
2.  实体（Entity）
3.  聚合（Aggregate）
4.  资源库（Repository）
5.  工厂（Factory）
6.  领域事件（Domain Event）
7.  领域服务（Domain Service）
8.  应用服务（Application Service）- 应用层

## 领域模型的职责

-   表示模型的是：实体、值对象、领域服务。这意味着所有领域逻辑都应该在这三种对象里。后续引入的领域事件也是一种领域逻辑。
-   聚合是为了进一步让领域逻辑更内聚，起到边界保护的作用。怎么保护呢？详见下面聚合设计原则部分。
-   工厂和资源库是为了管理领域对象的生命周期。工厂负责对象的创建（在复杂创建逻辑下才需要）。资源库负责聚合的加载、添加、修改、删除。
-   应用服务处于应用层，对领域逻辑编排、封装之后对上层接口层暴露。一次编排就是一个用户用例。

## 实体

### 实体定义：

简单说实体是具有属性和行为的对象。但这个定义不足以说明实体本质。因为值对象也有属性和行为。

实体的本质特征是具有唯一标识和具有业务连续性变化。业务连续性变化指随着时间推移实体的某些属性会发生变化，比如订单的状态随着订单履约流程随时变化，而订单号这个唯一标识是用来追踪这一变化的。

**唯一标识**

-   标识是唯一的，用来对外沟通的手段。就像中国公民具有身份证，订单具有订单号一样，实体有自己的唯一标识，可以是系统内部生成的也可以是系统外部传入的，可以由业务规则生成，也可以无业务含义。
-   标识是不会变的：实体的其他属性可能会变，但唯一标识在实体的整个生命周期都不会变。订单号不会随着订单的创建、支付、发货、关闭而改变。

**属性**：

属性是实体的特征表现，具体分为基本属性和组合属性。

-   基本属性：是那些由开发语言内置的基本类型就能表示的属性如name、description字段往往是个字符串。
-   组合属性：不是一个基本类型就能表示出来的特征，比如重量Weight，既有数字也有单位，2kg和2g。组合属性会被设计为值对象。

**行为**：

相对于属性代表的是实体的静态特征，行为是实体的动态特征。实体的行为有：

-   变更属性的行为比如更改描述
-   对自身属性加工计算的行为
-   跟别的属性协作的行为。需要依赖别的实体信息来做出决策。这一类行为的设计需要特别注意，和协作的对象要分清职责范围。

**注意**：实体的创建、增删改查不属于实体自身的行为，是实体的生命周期管理，需要交由工厂和资源库来负责。


## 值对象

值对象是对实体的描述。一个值对象只描述一个实体，少数情况一个值对象是个通用的描述，可能会用来描述多个实体。

注意：值对象也有自己的行为，尽可能把属于值对象自己的行为放到值对象里。

### **什么时候该定义为值对象？**

1.  【**无唯一标识**】没有唯一标识的对象都是值对象。这也值对象和实体的本质区别。
    1.  甚至订单项OrderLine也是一个值对象。对用户而言只关心订单里的哪个产品、数量多少、价格多少等信息，不关心第几个订单项。只是订单项可以作为单独表存储，从数据存储的角度要求这个表要有个唯一id，但这只是个技术id，不是唯一标识。
2.  【**验证逻辑**】有自我验证逻辑的属性，这些属性的验证逻辑如果放到实体里，会导致职责不够清晰，实体容易变的膨胀。
    1.  email属性，需要对是否一个有效的email地址做验证
    2.  收发货地址，需要验证地址格式有效性等
3.  【**计算逻辑**】有自我计算、换算逻辑的属性：
    1.  Weight重量属性，两个重量间的四则运算逻辑应归属于Weight值对象
    2.  Money金额属性，金额包含数量和货币单位，Money字段间有换算逻辑
4.  **【同类属性】**多个属性在描述一个领域特征
    1.  电话号码、座机、传真都在描述联系方式

### 值对象如何存储？

**存储到哪**？如果够简单就随实体表一起保存，如果复杂可以有单独的表存储（此时单独表里每行记录的唯一id只是为了技术手段使用，在聚合外这个id没有任何领域含义）

**谁来触发存储**？所属的实体

### 实体和值对象的区别？

是否具备唯一标识是实体和对象的本质区别。实体一旦创建会有后续状态变化，每个变化都需要通过唯一标识来追踪。

## 聚合

引入聚合是为了划分对象之间的边界，聚合即DDD引入的第四重边界。一个聚合至少有一个实体，承担最主要概念的实体就是聚合根，也叫根实体。聚合边界之内需要保持领域概念的完整性，边界之外聚合需要有独立性，需要跟别的聚合协作。对象之间是否应该构成一个聚合是DDD设计里的难点和重点。独立性和完整性是聚合的两个最重要特性。

### **聚合的独立性**

根实体是访问聚合边界的唯一入口。反过来讲若需要独立访问一个实体，则它只能作为聚合根。如果一个实体不是根实体，但同时真的需要被外界直接访问到，那么这个实体不应该在这个聚合中，应该独立成新的聚合。

-   【**case study**】比如账户和账户交易记录作为一个聚合，账户设计为根实体。但业务需要不通过账户而单独查询账户交易记录，比如所有账户的交易记录。如果账户交易记录不独立为一个聚合，则业务被迫需要每次通过账户来访问账户交易记录，这显然是不合理的。

**聚合的完整性**：

一个聚合代表一个完整的领域概念。完整性可以从几个方面理解：

1.  【共享生命周期】就像面向对象设计的合成关系composite，对象间的生命周期一致，需要同时被创建，同时被销毁。组成一个聚合的其他实体的操作由根实体来协调
    -   【**case study**】订单Order与订单项OrderLine，订单项不能离开订单而存在，订单如果没有订单项包含的信息就不是一个完整订单。同时用户只关心订单这个领域概念，用户可以不了解订单项这个领域概念，对用户而言只关心产品、产品数量、产品价格等信息。因此满足合成关系的对象往往会被设计为一个聚合。  
        
2.  【保证业务规则约束】施加在聚合内部各对象之上的各种业务约束需要满足，聚合的自我完备性需要保证包括数据、行为、约束
    -   【**case study**】采购订单中添加和删除订单项，必须满足多个订单项金额之和不能超过订单的审批额度。如果订单和订单项不在一个聚合，这个业务规则很难得到保证  
        
3.  【满足事务一致性】聚合通常被认为是一个事务的边界。也就是说聚合内的根实体、其他实体、值对象数据应该保持在一个事务边界内。如果不一致说明聚合边界设计存在疑问。加载和修改聚合就是一个事务单元。事务虽然是技术实现的范畴，但可以反过来验证聚合设计是否合理  
    -   【**case study**】如果订单和订单项是一个聚合，则订单和订单项的增删改必须满足一致性。如果分属不同的表存储，则订单表或者订单项表的插入失败会导致整个插入操作失败。当然事务的实际执行层面是聚合对应的资源库的职责。

### 聚合设计原则

-   【独立性】只有聚合根才是访问聚合边界的唯一入口
-   【完整性】尽量保持聚合领域概念的完整性
-   【访问原则】聚合之间应通过聚合根的身份标识进行引用，聚合内部的实体间可以通过对象引用
    -   其他聚合需要加载一个聚合时（往往通过领域服务/应用服务协调），必须通过目标聚合的资源库，并返回聚合的完整内容，但资源库可以有支持多种加载条件的接口。注意：直接查询类：是否可以通过资源库返回聚合的部分信息？有些实施DDD的做法是查询类不走领域层，用类似DAO的方式而不是资源库方式。我建议我们保持领域完整性，都走资源库查询，而且每个查询返回聚合整体。在领域层或者应用层做信息裁剪
    -   新增一个聚合必须调用根实体必要的校验和领域逻辑，并传递给资源库一个完整聚合
    -   更新一个聚合必须调用根实体必要的校验和领域逻辑，并传递给资源库一个完整聚合。**注意：**资源库的实现层面可以做到局部更新
-   【聚合协作】同一个BC的聚合间协作可以采用本地事务保持一致性，跨BC（即跨微服务）的聚合协作通过基于消息机制的最终一致性
-   【聚合与资源库】不要在聚合中使用资源库
-   【聚合粒度】在上述规则满足的前提下，聚合设计尽量小，小聚合带来小的事务粒度、有更好的性能


## 实体、值对象、聚合设计过程

1.  理顺领域对象图（对象图是领域建模的分析阶段的产出物）
2.  把领域对象设计为值对象，实体。值对象依附于某个实体。
3.  基于领域完整性和独立性识别出聚合、定义聚合根。**注意：当完整性和独立性产生矛盾时，优先满足独立性**。
    1.  本着聚合粒度尽量小原则，一开始可以把每个实体当作一个聚合。
    2.  合并实体。判断聚合是否足够完整？判断实体是否有独立性需求？如果实体A和实体B生命周期一致，同时A没有被外界独立访问的需求，则合并A和B为一个聚合。如果实体A有被独立访问的需求，则A作为单独聚合。
    3.  走查聚合设计粒度，综合考虑技术设计因素

## 资源库

-   资源库是对资源访问的一种抽象。资源库不局限于数据库，还可能是文件、网络存储。接口需要不依赖于具体的数据存储、ORM实现框架。
-   资源库像集合一样，提供添加、更新、获取聚合等接口，达到聚合的生命周期管理。
-   【与工厂的区别】工厂负责聚合实例的生，垃圾回收负责聚合实例的死，资源库就负责聚合记录的查询与增删改。
-   【与DAO的区别】DAO模式也能做到数据访问，但DAO没有边界控制作用，没有聚合作为一个整体的概念，service类想查什么表就查什么表。  
    

### 资源库设计原则

-   一个聚合一个repository，对聚合的生命周期管理只有资源库这个入口。
-   资源库的接口在领域层、实现在基础设施层
-   要访问聚合内的其他实体和值对象，也只能通过聚合对应的资源库进行，这就保护了聚合的封装性。即通过资源库获取聚合的引用，通过对象图的单一遍历方向获得聚合内部对象
-   不要包含领域逻辑

## 工厂

工厂负责聚合的对象实例化工作，需不需要定义专门的工厂类依据创建逻辑复杂与否而定。

-   不包含第二个实体的简单聚合可以直接new
-   聚合根实体自己定义静态创建方法
-   创建逻辑复杂时，设计单独的工厂类，隐藏创建细节

## 领域事件

### 领域内事件

如果一个应用服务对应的用例包含了多个聚合的状态改变，一个方案是通过领域内的事件来协同，但这带来异步响应编程模式。另一个方案是通过领域服务来编排多个聚合行为，这意味着所有事情都是在一个事务内同步完成。

两个方案各有优劣，事件方式优点是松耦合，异步响应，缺点是流程不直观，从应用服务角度很难知道一个完整流程是什么，不太方便查找问题，事件响应逻辑出错会带来事务一致性问题。领域服务编排方案优点是流程直观，事务一致性。缺点是如果编排逻辑发生变化需要改动的逻辑多，流程太多的话可能会有性能问题。

推荐：优先考虑使用领域服务编排完成。微服务架构下每个微服务的职责相对聚焦，一个用例通常不会同时修改多个聚合。如果需要修改多个聚合也应该是一个BC内的编排，可以通过应用服务启动的数据库事务来保证强一致性。另外领域设计提倡先从领域知识出发做聚合设计，技术实现问题比如性能问题往往放到后面做为走查领域设计的参考因素。如果没有强一致性需求的话，甚至可以通过向分布式消息队列发送领域间事件来达到自己发送自己消费的效果。

## 领域服务

领域服务也是一种领域逻辑，在分层架构里属于领域层。但领域服务没有任何属性/数据，只是一个领域行为/动作。

### 领域服务的三个典型场景

1.  协调多个聚合完成业务操作。因为聚合不能持有别的聚合对象，只能引用外部聚合根的唯一标识，因此需要跨聚合的业务操作需要领域服务来完成。（如果没有业务逻辑的话，部分场景也可以由应用服务来完成）。
2.  不适合任何聚合的领域行为。比如一个单据的导出行为是否应该属于该订单所在的聚合？由于导出需求涉及到格式的多样性等，建议设计成领域服务，由一个接口和多个实现类（每种格式）组成。
3.  领域行为需要与访问包括数据库在内的外部资源协作时。

### 领域服务设计原则

-   粒度要小，一个领域服务只做一件事，便于应用服务编排。
-   作为参考可以要求领域服务的名称必须包含一个动词。对于同一个聚合关联的添加、更新、查询、删除等相关领域服务建议设计为四个不同的类，避免领域类太大。
-   一个比较常见的坏习惯是没有尽最大努力为领域行为找到一个归属的实体，轻易定义成领域服务，这容易让领域服务类变成"上帝类"。

## 应用服务

应用服务属于分层架构里的应用层，每个用户用例对应一个方法。

-   外观模式：对外提供粗粒度接口、对内分配职责的协作作用。类似设计模式的外观模式。
-   坚持不做业务决策的原则：应用服务自己不做任何业务逻辑的决策。每当你觉得应用服务里的代码做出的业务决策是跟本BC业务逻辑有关联时，往往是把不必要的业务代码蔓延到这层了。
-   应用服务方法的入参和出参都是DTO，调用领域层需要传入entity，返回interface层需要把entity转成DTO

应用服务的两个典型场景：

-   不包含领域逻辑的业务服务应被定义为应用服务。
-   与横切关注点协作的服务应被定义为应用服务：事务、认证授权等

### 应用服务与领域服务的区别？

看起来领域服务和应用服务都能做编排功能，原则上是应用服务不应该包含领域层的逻辑，那怎么判断什么是领域层的业务逻辑？这个问题没有标准答案，设计时不用太条条框框。一个简单的判断标准可以自问一下：这段代码蕴含的知识是否与本BC的主要职责域直接有关？如果相关的话不要在放应用服务。

-   洋葱架构作者和Eric Evans都提到过不用规定的太死，外层一定只能调用它的直接内层。只要调用关系不会破坏层次的耦合就行（外层依赖内层，内层不依赖外层）。也就是说应用服务不一定非要通过领域服务来访问资源库和根实体，也可以直接引用资源库和根实体，领域服务也可以引用资源库和根实体。
-   不要用领域服务对根实体的方法做简单封装后供应用服务调用


|     |   应用服务   |  领域服务   |  聚合/实体根   |  资源库   |
| --- | --- | --- | --- | --- |
|  应用服务   |  一个应用服务**不要**访问另一个应用服务   |   应用服务能访问多个领域服务  |  应用服务能访问聚合即根实体   |  应用服务能访问资源库   |
|   聚合  |   聚合**不能**访问应用服务  |   聚合**不能**访问领域服务  |  通过领域服务来协作多个聚合，一个聚合只能接受另一个聚合作为参数传入   |  聚合**不能**访问资源库（聚合是业务的最小边界，聚合内不依赖任何外部资源）   |
|   资源库  |  资源库**不能**访问应用服务   |  资源库**不能**访问领域服务   |  资源库**不能**访问聚合，根实体作文入参传入资源库实现接口，需要先被转换成持久化对象  |  一个资源库**不能**访问另一个资源库   |
|   领域服务  |  领域服务**不能**访问应用服务   |  如果需要组装出粒度大的领域服务，领域服务能访问多个领域服务   |  领域服务能访问聚合即根实体   |    领域服务能访问资源库  |


## 项目结构

[DDD项目结构](https://github.com/freshchen/fresh-keeping/tree/master/java/ddd-archetype)


## 参考链接


##### 标签
#architecture #DDD 